% \VignetteIndexEntry{bartMachine Vignette}
% \VignetteKeywords{bartMachine}
% \VignettePackage{bartMachine}


\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{textcomp}
\usepackage{phaistos}
\usepackage[margin=1.00in]{geometry}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage[round]{natbib}
\usepackage{hyperref}


\newcommand{\bv}[1]{\boldsymbol{#1}}
\newcommand{\qu}[1]{``#1''}
\renewcommand{\min}[1]{\text{min}\braces{#1}}
\renewcommand{\max}[1]{\text{max}\braces{#1}}
\newcommand{\treet}[1]{\text{\scriptsize \PHplaneTree}_{#1}}
\newcommand{\treeleaft}[1]{\text{\scriptsize \PHplaneTree}_{#1}^{\text{\tiny \textleaf}}}
\newcommand{\leaf}{\text{\scriptsize \textleaf}}
\newcommand{\beqn}{\begin{eqnarray*}}
\newcommand{\eeqn}{\end{eqnarray*}}
\newcommand{\bneqn}{\begin{eqnarray}}
\newcommand{\eneqn}{\end{eqnarray}}
\newcommand{\parens}[1]{\left(#1\right)}
\newcommand{\braces}[1]{\left\{#1\right\}}
\newcommand{\bracks}[1]{\left[#1\right]}
\newcommand{\squared}[1]{\parens{#1}^2}
\newcommand{\tothepow}[2]{\parens{#1}^{#2}}
\newcommand{\errorrv}{\mathcal{E}}
\newcommand{\berrorrv}{\bv{\errorrv}}
\newcommand{\normnot}[2]{\mathcal{N}\parens{#1,\,#2}}
\newcommand{\multnormnot}[3]{\mathcal{N}_{#1}\parens{#2,\,#3}}
\newcommand{\invgammanot}[2]{\text{InvGamma}\parens{#1,\,#2}}
\newcommand{\uniform}[2]{\mathrm{U}\parens{#1,\,#2}}
\newcommand{\zerovec}{\bv{0}}
\newcommand{\0}{\zerovec}
\newcommand{\sigsq}{\sigma^2}
\newcommand{\I}{\bv{I}}
\newcommand{\X}{\bv{X}}
\newcommand{\E}{\bv{E}}
\newcommand{\R}{\bv{R}}
\newcommand{\Z}{\bv{Z}}
\newcommand{\Y}{\bv{Y}}
\newcommand{\M}{\bv{M}}
\newcommand{\x}{\bv{x}}
\newcommand{\y}{\bv{y}}
\newcommand{\prob}[1]{\mathbb{P}\parens{#1}}
\newcommand{\cprob}[2]{\prob{#1~|~#2}}
\newcommand{\expe}[1]{\mathbb{E}\bracks{#1}}
\newcommand{\expesub}[2]{\mathbb{E}_{#1}\bracks{#2}}
\newcommand{\cexpe}[2]{\expe{#1 ~ | ~ #2}}
\newcommand{\iid}{~{\buildrel iid \over \sim}~}
\newcommand{\mathand}{~~\text{and}~~}
\newcommand{\yhat}{\hat{y}}
\newcommand{\oneover}[1]{\frac{1}{#1}}
\newcommand{\Hint}{H_{\text{internals}}}
\newcommand{\Hterminals}{H_{\text{terminals}}}
\newcommand{\Hleavesbelow}{H_{\text{leaves}\cdot\text{below}}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\padjeta}{p_{\text{adj}}(\eta)}
\newcommand{\padjetastar}{p_{\text{adj}}(\eta^*)}
\newcommand{\nadjeta}{n_{j\cdot\text{adj}}(\eta)}
\newcommand{\nadjetastar}{n_{j^*\cdot\text{adj}}(\eta^*)}
\newcommand{\nadjcheta}{n_{j\cdot\text{adj}\cdot\text{ch}}(\eta)}
\newcommand{\nadjchetastar}{n_{j\cdot\text{adj}\cdot\text{ch}}(\eta^*)}
\newcommand{\probsplit}[1]{\mathbb{P}_{\text{SPLIT}}\parens{#1}}
\newcommand{\probrule}[1]{\mathbb{P}_{\text{RULE}}\parens{#1}}
\newcommand{\Roneton}{R_1, \ldots, R_n}
\newcommand{\Rlonetonl}{R_{\ell_1}, \ldots, R_{\ell_{n_\ell}}}
\newcommand{\RLlonetonlL}{R_{\ell_{L,1}}, \ldots, R_{\ell_{L, n_{\ell,L}}}}
\newcommand{\RRlonetonlR}{R_{\ell_{R,1}}, \ldots, R_{R,\ell_{n_{\ell,R}}}}
\newcommand{\Rbar}{\bar{R}}
\newcommand{\sigsqmu}{\sigsq_\mu}
\newcommand{\doneover}[1]{\dfrac{1}{#1}}
\newcommand{\Rones}{R_{1,1}, \ldots, R_{1, \none}}
\newcommand{\Rtwos}{R_{2,1}, \ldots, R_{2, \ntwo}}
\newcommand{\Ronestars}{R_{1^*,1}, \ldots, R_{1^*, \nonestar}}
\newcommand{\Rtwostars}{R_{2^*,1}, \ldots, R_{2^*, \ntwostar}}
\newcommand{\none}{n_{1}}
\newcommand{\ntwo}{n_{2}}
\newcommand{\nonestar}{n_{1^*}}
\newcommand{\ntwostar}{n_{2^*}}
\newcommand{\etastar}{\eta_*}
\newcommand{\etaone}{\eta_1}
\newcommand{\etatwo}{\eta_2}
\newcommand{\etaonestar}{\eta_{1^*}}
\newcommand{\etatwostar}{\eta_{2^*}}
\renewcommand{\exp}[1]{\text{exp}\parens{#1}}
\newcommand{\pval}{p_{\text{val}}}

\title{\texttt{bartMachine}: A Powerful Tool for Machine Learning}
\author{Adam Kapelner\footnote{Both authors contributed equally to this work.} ~and Justin Bleich$^*$ \\~\\\vspace{0.2cm}
The Wharton School of the University of Pennsylvania}

\begin{document}
\maketitle

\begin{abstract}
We present a new package in \texttt{R} implementing Bayesian Additive Regression Trees (\texttt{BART}). The package introduces many new features for data analysis using \texttt{BART} such as variable selection, interaction detection, model diagnostic plots, incorporation of missing data and the ability to save trees for future prediction. It is significantly faster than the current \texttt{R} implementation, parallelized, and capable of handling both large sample sizes and high-dimensional data. 
\end{abstract}

\section{Introduction}

Ensemble-of-trees methods have become popular choices for forecasting in both regression and classification problems. Algorithms such as Random Forests \citep{Breiman2001} and stochastic gradient boosting \citep{Friedman2002} are two well-established and widely employed procedures. Recent advances in ensemble methods include Dynamic Trees \citep{Taddy2011} and Bayesian Additive Regression Trees \citep[\texttt{BART},][]{Chipman2010}, which depart from predecessors in that they rely on an underlying Bayesian probability model rather than a pure algorithm. \texttt{BART} has demonstrated substantial promise in a wide variety of simulations and real world applications such as predicting avalanches on mountain roads \citep{Blattenberger2014}, predicting how transcription factors interact with DNA \citep{Zhou2008} and predicting movie box office revenues \citep{Eliashberg2010}. This paper introduces \texttt{bartMachine}, a new \texttt{R} package that significantly expands the capabilities of using \texttt{BART} for data analysis. 

Currently, there exists a single implementation of \texttt{BART} on CRAN: \texttt{BayesTree}, the package developed by the algorithm's original authors. One of the major drawbacks of this implementation is its lack of a \texttt{predict} function. Test data must be provided as an argument during the training phase of the model. Hence it is impossible to generate forecasts on future data without re-fitting withe entire model. Since the run time is not trivial, forecasting becomes an arduous exercise. A significantly faster implementation of \texttt{BART} that contains master-slave parallelization exists as \citet{Pratola2013}, but this is only available as standalone C++ source code and not integrated with \texttt{R}. 

The goal of \texttt{bartMachine} is to provide a fast, easy-to-use, visualization-rich machine learning package for \texttt{R} users. Our implementation of \texttt{BART} is in \texttt{Java} and is integrated into \texttt{R} via \texttt{rJava} \citep{rJava}. From a runtime perspective, our algorithm is significantly faster and is parallelized, allowing computation on as many cores as desired. Not only is the model construction itself parallelized, but the additional features such as prediction, variable selection, and many others can be divided across cores as well.  

Additionally, we include a variety of expanded and new features. We implement the ability to save trees in memory and provide convenience functions for prediction on test data. We also include plotting functions for both credible and predictive intervals and plots for visually inspecting convergence of \texttt{BART}'s Gibbs sampler. We expand variable importance exploration to include permutation tests and interaction detection. We implement recently developed features for \texttt{BART} including a principled approach to variable selection and the ability to incorporate in prior information for covariates \citep{Bleich2013}. We also implement the strategy found in \citet{Kapelner2013} to incorporate missing data during training and handle missingness during prediction.  

In Section \ref{sec:background}, we provide an overview of \texttt{BART} with a special emphasis on the features that have been extended. In Section~\ref{sec:package} we provide a general introduction to the package, highlighting the novel features. Section~\ref{sec:regression_features} provides step-by-step examples of the regression capabilities and Section~\ref{sec:classification_features} introduces additional step-by-step examples of features unique to classification problems. We conclude in Section \ref{sec:discussion}. Appendix~\ref{app:implementation} discusses the details of our implementation and how it differs from \texttt{BayesTree}. Appendix~\ref{app:bakeoff} offers predictive performance comparisons.

\section{Overview of \texttt{BART}}\label{sec:background}

\texttt{BART} provides a unique approach to nonparametric function estimation using regression trees. Regression trees rely on recursive binary partitioning of predictor space into a set of hyperrectangles in order to approximate some unknown function $f$. Such trees have received praise for their ability to flexibly fit interactions and nonlinearities. Models composed of sums of regression trees are able to capture additive effects in $f$ better than single trees. 

\texttt{BART} can be considered a sum-of-trees ensemble, with a novel estimation approach which relies on a fully Bayesian probability model.  Specifically, the \texttt{BART} model can be expressed as:

\bneqn\label{eq:bart}
\Y = f(\X) + \berrorrv \approx \treeleaft{1}(\X) + \treeleaft{2}(\X) + \ldots + \treeleaft{m}(\X) + \berrorrv, \quad\quad \berrorrv \sim \multnormnot{n}{\zerovec}{\sigsq\I_n}
\eneqn

Here we have $m$ distinct regression trees, each composed of a tree structure, denoted by $\treet{}$, and the parameters at the terminal nodes (also called leaves), denoted by $\leaf$. The two together, denoted as $\treeleaft{}$ represents an entire tree with both its structure and set of leaf parameters.

The structure of a given tree $\treet{t}$ includes information on how any observation recurses down the tree. For each nonterminal (internal) node of the tree, there is a \qu{splitting rule} taking the form $\x_j < c$ consisting of the \qu{splitting variable} $\x_j$ and the \qu{splitting value} $c$. An observation moves to the left daughter node if the condition set by the splitting rule is satisfied and to the right daughter node otherwise. The process continues until a terminal node is reached. Then, the observation receives the leaf value of the terminal node as its predicted value. We denote the set of tree's leaf parameters as  $\leaf_t = \braces{\mu_{t,1}, \mu_{t,2}, \ldots, \mu_{t_{b_t}}}$ where $b_t$ is the number of terminal nodes for a given tree.

\texttt{BART} can be distinguished from other ensemble-of-trees models due to its underlying probability model. As a Bayesian model, \texttt{BART} consists of a set of priors for the structure and the leaf parameters and a likelihood for data in the terminal nodes. The aim of the priors is to provide regularization, preventing any single regression tree from dominating the total fit. 

We provide an overview of the \texttt{BART} priors and likelihood and then discuss how draws from the posterior distribution are made. A more complete exposition can be found in \citet{Chipman2010}. 

\subsection{Priors and Likelihood}\label{subsec:prior_likelihood}

There are three priors for the \texttt{BART} model: a prior on the tree structure itself, a prior on the leaf parameters, and a prior on the error variance $\sigsq$. The prior on $\sigsq$ is independent from the other two and each tree is independent, yielding:

\beqn 
\prob{\treeleaft{1},\ldots,\treeleaft{m}, \sigsq} &=& \bracks{\prod_{t}\prob{\treeleaft{t}}}\prob{\sigsq} 
   = \bracks{\prod_{t}\cprob{\leaf_t}{\treet{t}}\prob{\treet{t}}}\prob{\sigsq}  \\
&=& \bracks{\prod_{t}\prod_{\ell}\cprob{ \mu_{t,\ell}}{\treet{t}}\prob{\treet{t}}}\prob{\sigsq}
\eeqn

\noindent where the last line follows from an additional assumption of conditional independence of the leaf parameters given the tree's structure. 

The first prior is on the locations of nodes within the tree. Nodes at depth $d$ are nonterminal with probability $\alpha(1+d)^{-\beta}$ where $\alpha \in (0,1)$ and $\beta \in [0, \infty]$. This prior keeps the trees shallow, limiting complexity of any single tree. Default values for these hyperparameters of $\alpha = 0.95$ and $\beta = 2$ are recommended by \citet{Chipman2010}. 

For nonterminal nodes, splitting rules have the following prior. First, a predictor is randomly selected to serve as the splitting variable. In the original formulation, each available predictor is equally likely to be chosen, but this is relaxed in our implementation to allow an arbitrary discrete distribution (see Section~\ref{subsec:cov_prior}). Then, the splitting value is selected by randomly choosing a value of the selected predictor with equal probability. 

The third prior is on the leaf parameters. Given a tree with a set of terminal nodes, each terminal node (or leaf) has a continuous parameter (the leaf parameter) representing the \qu{best guess} of the response in this partition of predictor space. This parameter is the fitted value assigned to any observation that lands in that node. The prior on each of the leaf parameters is given as: $\mu_\ell \iid \normnot{\mu_\mu}{\sigsq_\mu}$. The expectation, $\mu_\mu$, is picked to be the range center, $(y_{\text{min}} + y_{\text{max}}) / 2$. The variance is empirically chosen so that the range center plus or minus $k = 2$ variances cover 95\% of the provided response values in the training set (by default). The aim of this prior is to provide model regularization by shrinking the leaf parameters towards the center of the distribution of the response.

The final prior is on the error variance and is chosen to be $\sigsq \sim \invgammanot{\nu / 2}{\nu\lambda / 2}$. $\lambda$ is determined from the data so that there is a $q = 90\%$ a priori chance (by default) that the \texttt{BART} model will improve upon the RMSE from an ordinary least squares regression. Therefore, the majority of the prior probability mass lies below the RMSE from least squares regression. Additionally, this prior limits the probability mass placed on small values of $\sigsq$ to prevent overfitting.

Note that the adjustable hyperparameters are $\alpha$, $\beta$, $k$, $\nu$ and $q$. Default values generally provide good performance, but optimal tuning can be achieved via cross-validation, an automatic feature implemented and described in Section~\ref{subsec:model_building}.

Along with a set of priors, \texttt{BART} specifies the likelihood of responses in the terminal nodes. They are assumed a priori Normal with the mean being the \qu{best guess} in the leaf at the current moment (in the Gibbs sampler) and variance being the best guess of the variance at the moment i.e. $\y_\ell \sim \normnot{\mu_\ell}{\sigsq / m}$. Note that $\sigsq$ is scaled by the number of trees in order that the sum of the variances across the $m$ trees is $\sigsq$. 

\subsection{Posterior Distribution and Prediction} \label{subsec:posterior}

A Gibbs sampler \citep{Geman1984} is employed to generate draws from the posterior distribution of $\mathbb{P}(\treeleaft{1}, \ldots, \treeleaft{m}, \sigsq ~|~\y)$. A key feature of the Gibbs sampler for \texttt{BART} is to employ a form of ``Bayesian backfitting'' \citep{Hastie2000} where the $j$th tree is fit iteratively, holding all other $m-1$ trees constant by exposing only the residual response that remains unfitted: 

\bneqn\label{eq:response_unfitted}
\R_j := \y - \sum_{t \neq j} \treeleaft{t}(\X).
\eneqn

The Gibbs sampler,

\bneqn\label{eq:gibbs_sampler}
1: && \treet{1} ~|~ \R_{-1}, \sigsq \\ \nonumber
2: && \leaf_1 ~|~ \treet{1}, \R_{-1}, \sigsq \\ \nonumber
3: && \treet{2} ~|~ \R_{-2}, \sigsq \\ \nonumber
4: && \leaf_2 ~|~ \treet{2}, \R_{-2}, \sigsq \\  \nonumber
\vdots &&  \\\nonumber
2m -1: && \treet{m} ~|~ \R_{-m}, \sigsq \\\nonumber
2m: && \leaf_m ~|~ \treet{m}, \R_{-m}, \sigsq \\ \nonumber
2m + 1: && ~\,\sigsq ~|~ \treet{1}, \leaf_1, \ldots, \treet{m}, \leaf_m, \E, \nonumber
\eneqn

\noindent proceeds by first proposing a change to the first tree's structure $\treet{}$ which are accepted or rejected via a Metropolis-Hastings step \citep{Hastings1970}. Note that sampling from the posterior of the tree structure does not depend on the leaf parameters, as they can be analytically margined out of the computation (see Appendix ~\ref{subapp:grow_step}). Given the tree structure, samples from the posterior of the $b$ leaf parameters $\leaf_1 := \braces{\mu_1, \ldots, \mu_b}$  are then drawn. This procedure proceeeds iteratively for each tree, using the updated set of partial residuals $\R_j$. Finally, conditional on the updated set of tree structures and leaf parameters, a draw from the posterior of $\sigsq$ is made based on the full model residuals $\E := \y - \sum_{t = 1}^m \treeleaft{t}(\X)$.

Within a given terminal node, since both the prior and likelihood are normally distributed, the posterior of each of the leaf parameters in $\leaf$ is conjugate normal with its mean being a weighted combination of the likelihood and prior parameters (lines $2,~4, \ldots, 2m$ in equation set \ref{eq:gibbs_sampler}). Due to the normal-inverse-gamma conjugacy, the posterior of $\sigsq$ is inverse gamma as well (line $2m+1$ in equation set \ref{eq:gibbs_sampler}). The complete expressions for these posteriors can be found in \citet{Gelman2004}. 

Lines $1,~3,\ldots,~2m-1$ in equation set \ref{eq:gibbs_sampler} rely on Metropolis-Hastings draws from the posterior of the tree distributions. These involve introducing small perturbations to the tree structure: growing a terminal node by adding two daughter nodes, pruning two daughter nodes (rendering their parent node terminal), or changing a split rule. We denote these possible alterations as: GROW, PRUNE, and CHANGE.\footnote{In the original formulation, \citet{Chipman2010} include an additional alteration called SWAP. Due to the complexity of bookkeeping associated with this alteration, we do not implement it.} The mathematics associated with the Metropolis-Hastings step is simple but is tedious, and we refer the interested reader to Appendix~\ref{app:implementation} for the explicit calculations. Once again, over many Gibbs samples, trees can dynamically morph their structure in an effort to capture the fit left currently unexplained.

\citet{Pratola2013} argue that a CHANGE step is unnecessary for sufficient mixing of the Gibbs sampler. While we too observed this to be true for estimates of the posterior means, we found that omitting CHANGE can negatively impact the variable inclusion proportions (the feature introduced in Section~\ref{subsec:variable_importance}). As a result, we implement a modified CHANGE where we only propose new splits for nodes that are singly internal: both children nodes  are terminal nodes (details are given in Appendix~\ref{subapp:change_step}).

All $2m+1$ steps represent a \textit{single} Gibbs iteration. We have observed that generally no more than 1,000 iterations are needed as ``burn-in'' (see Section~\ref{subsec:assumption_checking} for convergence diagnostics). An additional 1,000 iterations is usually sufficient to serve as draws from the posterior for $f(\x)$. A single predicted value $\hat{f}(\x)$ can be obtained by taking the average of the posterior values and a quantile estimate can be obtained by computing the appropriate quantile of the posterior values. Additional features of the posterior distribution will be discussed in Section~\ref{sec:regression_features}.

\subsection{BART for Classification} \label{subsec:probit_bart}

\texttt{BART} can easily be modified to handle classification problems for categorical response variables. In \citet{Chipman2010},  only binary outcomes were explored but recent work has extended \texttt{BART} to the multiclass problem \citep{Kindo2013}. Our implementation handles binary classification and we plan to implement multiclass outcomes in a future release.

For the binary classification problem (coded with outcomes ``0'' and ``1''), we assume a probit model,

\beqn
\cprob{\Y = 1}{\X} = \Phi\parens{\treeleaft{1}(\X) + \treeleaft{2}(\X) + \ldots + \treeleaft{m}(\X)},
\eeqn

\noindent where $\Phi$ denotes the cumulative density function of the standard normal distribution. In this formulation, the sum-of-trees model serves as an estimate of the conditional probit at $\x$ which can be easily transformed into a conditional probability estimate of $Y=1$. 

In the classification setting, the prior on $\sigsq$ is not needed as the model assumes $\sigsq=1$. The prior on the tree structure remains the same as in the regression setting and a few minor modifications are required for the prior on the leaf parameters. 

Sampling from the posterior distribution is again obtained via Gibbs sampling with a Metropolis-Hastings step outlined in Section~\ref{subsec:posterior}. Following the data augmentation approach of \citep{Albert1993} an additional vector of latent variables $\Z$ is introduced into the Gibbs sampler. Then, a new step is created in the Gibbs sampler where draws of $\Z\,|\,\y$ are obtained by conditioning on the sum-of-trees model:

\beqn
Z_i~|~y_i=1 &\sim& \max{N\parens{\sum_t \treeleaft{t}\parens{\X},1}, \,0} \mathand \\
Z_i~|~y_i = 0  &\sim& \min{N\parens{\sum_t \treeleaft{t}\parens{\X},1}, \,0}.
\eeqn

\noindent Next, $\Z$ is used as the response vector instead of $\y$ in all steps of  Equation~\ref{eq:gibbs_sampler}.

Upon obtaining a sufficient number of samples from the posterior, inferences can be made using the the posterior distribution of conditional probabilities and classification can be undertaken by applying a threshold to the to the means (or another summary) of these posterior probabilities. The relevant classification features of \texttt{bartMachine} are discussed in Section~\ref{sec:classification_features}.



\section{The \texttt{bartMachine} package}\label{sec:package}

The package \texttt{bartMachine} provides a novel implementation of Bayesian Additive Regression Trees in \texttt{R}. The algorithm is substantially faster than the current \texttt{R} package \texttt{BayesTree} and our implementation is parallelized at the Gibbs sample level during prediction.  Additionally, the interface with \texttt{rJava} allows for the entire posterior distribution of tree ensembles to persist throughout the \texttt{R} session, allowing for prediction and other calls to the trees without having to re-run the Gibbs sampler (a limitation in the current implementation). The model object cannot persist across sessions (using \texttt{R}'s save command for instance) and we view the addition of this feature as future work. Since our implementation is different from \texttt{BayesTree}, we provide a predictive accuracy bakeoff on different datasets in Appendix~\ref{app:bakeoff} which illustrates that the two are about equal.

\subsection{Speed Improvements and Parallelization}\label{subsec:speed_and_parallelization}

We make a number of significant speed improvements over the original implementation. 

First, \texttt{bartMachine} is fully parallelized (with the number of cores customizable) during model creation, prediction, and many of the other features. During model creation, we chose to parallelize by creating one independent Gibbs chain per core. Thus, if we have 500 burn-in samples and 1,000 post burn-in samples and four cores, each core would sample 750 samples: 500 for a burn-in and 250 post burn-in samples. The final model will aggregate the 250 post burn-in samples for the four cores yielding the desired 1,000 total post burn-in samples. This has the drawback of effectively running the burn-in serially, but has the added benefit of reducing auto-correlation of the sum-of-trees samples in the posterior samples since the chains are independent which may provide greater predictive performance. Parallelization at the level of likelihood calculations is left for a future release. Parallelization for prediction and other features scale linearly in the number of cores.

Additionally, we take advantage of a number of additional computational shortcuts:

\begin{enumerate}[1.]
\item Computing the unfitted responses for each tree (Equation~\ref{eq:response_unfitted}) can be accomplished by keeping a running vector and making entry-wise updates as the Gibbs sampler (Equation~\ref{eq:gibbs_sampler}) progresses from step 1 to $2m$. Additionally, during the $\sigsq$ step $2m + 1$, the residuals do not have to be computed by dropping the data down all the trees.
\item Each node caches its acceptable variables for split rules and the acceptable unique split values so they do not need to be calculated at each tree sampling step. This speed enhancement, which we call \textit{memcache} comes at the expense of memory and may cause issues for large data sets. We include a toggle in our implementation defaulted to ``on.''
\item Careful calculations in Appendix \ref{app:implementation} eliminate many unnecessary computations. For instance, the likelihood ratios are only functions of the squared sum of responses and no longer require computing the sum of the responses squared.
\end{enumerate}

Figure~\ref{fig:time_plots} displays model creation speeds for different values of $n$ on a linear model with $p=20$, normally distributed covariates, $\beta_1, \ldots, \beta_{20} \iid \uniform{-1}{1}$, and standard normal noise. Note that we do not vary $p$ as it was already shown in \citet{Chipman2010} that \texttt{BART}'s computation time is largely unaffected by the dimensionality of the problem (relative to the influence of sample size).  We include results for \texttt{BART} using \texttt{BayesTree} \citep{Chipman2010}, \texttt{bartMachine} with one and four cores, the \textit{memcache} option on and off, as well as four cores, \textit{memcache} off and computation of in-sample statistics off (all with $m=50$ trees). We also include Random Forests via the package \texttt{randomForest} \citep{Liaw2002} with its default settings.

\begin{figure}[htp]
\centering
\begin{subfigure}[c]{.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{speed_full}
                \caption{Large sample sizes}
                \label{fig:time_plots_large_sample}
        \end{subfigure}
\begin{subfigure}[c]{.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{speed_zoomed}
                \caption{Small sample sizes}
                \label{fig:time_plots_small_sample}
        \end{subfigure}
\caption{Model creation times as a function of sample size for a number of settings of \texttt{bartMachine}, \texttt{BayesTree} and \texttt{RandomForests}. Simulations were run on a quad-core 3.4GHz Intel i5 desktop with 24GB of RAM running the Windows 7 64bit operating system.}
\label{fig:time_plots}
\end{figure}

We first note that Figure~\ref{fig:time_plots_large_sample} demonstrates that the \texttt{bartMachine} model creation runtime is approximately linear in $n$. There is about a 30\% speed-up when using four cores instead of one. The \textit{memcache} enhancement should be turned off only with sample sizes larger than $n=20,000$. Noteworthy is the 50\% reduction in time of constructing the model when not computing in-sample statistics. In-sample statistics are computed by default because the user generally wishes to see them. Also, for the purposes of this comparison, \texttt{BayesTree} models compute the in-sample statistics by necessity since the trees are not saved. The \texttt{randomForest} implementation becomes slower just after $n=1,000$ due to its reliance on a greedy exhaustive search at each node.

Figure~\ref{fig:time_plots_small_sample} displays results for smaller sample sizes ($n \leq 2,000$) that are often encountered in practice. We observe the \textit{memcache} enhancement provides about a 10\% speed improvement. Thus, if memory is an issue, it can be turned off with little performance degradation.

\subsection{Missing Data in \texttt{BART}}\label{subsec:missing_data}

\texttt{bartMachine} implements a native method for incorporating missing data into both model creation and future prediction with test data. The details are given in \citet{Kapelner2013} but we provide a brief summary here.

There are a number of ways to incorporate missingness into tree-based methods (see \citealp{Ding2010} for a review). The method implemented here is known as \qu{Missing Incorporated in Attributes} \citep[MIA, ][section 2]{Twala2008} which natively incorporates missingness by augmenting the nodes' splitting rules to (a) also handle sorting the missing data to the left or right and (b) use missingness \textit{itself} as a variable to be considered in a splitting rule. Algorithm \ref{alg:mia} summarizes these new splitting rules as they are implemented within the package.

Implementing MIA into the \texttt{BART} procedure is straightforward. These new splitting rules are sampled uniformly during the GROW or CHANGE steps. For example, a splitting rule might be \qu{$\x_j < c$ or $\x_j$ is missing.} To account for splitting on missingness itself, we create dummy vectors of length $n$ for each of the $p$ attributes, denoted $\M_1, \ldots, \M_p$, which assume the value 1 when the entry is missing and 0 when the entry is present. The original training matrix is then augmented with these dummies, giving the opportunity to select missingness \textit{itself} when choosing a new splitting rule during the grow or change steps. Note that this can increase the number of predictors by up to a factor of 2. We illustrate the building a \texttt{BART} model with missing data in  Section~\ref{subsec:incorporating_missing_data}. As described in \citet[][Section 6]{Chipman2010}, \texttt{BART}'s runtime increases negligibly in the number of covariates and this has been our experience using the augmented training matrix.

\begin{algorithm}[htp]
\caption{The MIA choices for all attributes $j \in \braces{1, \ldots, p}$ and all split points $x^*_{ij}$ where $i \in \braces{1,\ldots,n}$ during a GROW or CHANGE step in \texttt{bartMachine}.}
\begin{algorithmic}[1]
\State If $x_{ij}$ is missing, send it $\longleftarrow$; if it is present and $x_{ij} \leq x^*_{ij}$, send it $\longleftarrow$, otherwise $\longrightarrow$.
\State If $x_{ij}$ is missing, send it $\longrightarrow$; if it is present and $x_{ij} \leq x^*_{ij}$, send it $\longleftarrow$, otherwise $\longrightarrow$.
\State If $x_{ij}$ is missing, send it $\longleftarrow$; if it is present, send it $\longrightarrow$.
\end{algorithmic}
\label{alg:mia}
\end{algorithm}

\subsection{Principled Variable Selection}\label{subsec:variable_selection}

Our package also implements the variable selection procedures developed in \citet{Bleich2013}, which is best applied to data problems where the number of covariates influencing the response is small relative to the total number of covariates. We give a brief summary of the procedures here. 

In order to select variables, we make use of the \qu{variable inclusion proportions,} the proportion of times each predictor is chosen as a splitting rule divided by the total number of splitting rules appearing in the model (see Section~\ref{subsec:variable_importance} for more details). The variable selection procedure can be outlined as follows: 

\begin{enumerate}[1.]
\item Compute the model's variable inclusion proportions.
\item Permute the response vector, thereby breaking the relationship between the covariates and the response. Rebuild the model and compute the \qu{null} variable inclusion proportions. Repeat this a number of times to create a null permutation distribution. 
\item Three selection rules are can be used depending on the desired stringency of selection:
\begin{enumerate}
\item Local Threshold: Include a predictor $\x_k$ if its variable inclusion proportion exceeds the $1-\alpha$ quantile of its own null distribution.
\item Global Max Threshold: Include a predictor $\x_k$ if its variable inclusion proportion exceeds the $1-\alpha$ quantile of the distribution of the maximum of the null variable inclusion proportions from each permutation of the response.
\item Global SE Threshold: Select $\x_k$ if its variable inclusion proportion exceeds a threshold based from its own null distribution mean and SD with a global multiplier shared by all predictors.
\end{enumerate}

\end{enumerate}


The Local procedure is the least stringent in terms of selection and the Global Max procedure the most. The Global SE procedure is a compromise, but behaves more similarly to the Global Max. \citet{Bleich2013} demonstrate that the best procedure depends on the underlying sparsity of the problem, which is often unknown. Therefore, the authors include an additional procedure that chooses the best of these thresholds via cross-validation and this method is also implemented in \texttt{bartMachine}. Examples of these procedures for variable selection are provided in Section~\ref{subsec:variable_selection_regression}.

\section{Regression Features}\label{sec:regression_features}

We illustrate the package features by using both real and simulated data, focusing first on regression problems. 

\subsection{Computing parameters}\label{subsec:computing_parameters}

We first set some computing parameters. We allow up to 5GB of RAM for the Java heap (although we never used more than 1GB during this paper's exploration)\footnote{Note that the maximum amount of memory can be set only \textit{once} at the beginning of the \texttt{R} session (a limitation of \texttt{rJava} since only one Java Virtual Machine can be initiated per session), but the number of cores can be respecified at any time.} and we set the number of computing cores available for use to 4.

\begin{verbatim}
> library(bartMachine)
> data(automobile)
> #kill rows with missingness
> automobile = na.omit(automobile)
> #pull out X and y
> y = automobile$price
> X = automobile; X$price = NULL
> set_bart_machine_num_cores(4)
> init_java_for_bart_machine_with_mem_in_mb(5000)
\end{verbatim}

The following Sections \ref{subsec:model_building} -- \ref{subsec:variable_selection_regression} use a dataset obtained from UCI \citep{Bache2013}. The $n=201$ observations are automobiles and the goal is to predict each automobile's price from 25 features (15 continuous and 10 nominal), first explored by \citet{Kibler1989}.\footnote{We first preprocess the data. We first drop one of the nominal predictors (car company) due to too many categories (22). We then coerce two of the of the nominal predictors to be continuous. Further, the response variable, price, was logged to reduce right skew in its distribution.} This dataset also contains missing data.

\subsection{Model Building}\label{subsec:model_building}

We are now are ready to construct a \texttt{bartMachine} model. The default hyperparameters generally follow the recommendations of \citet{Chipman2010} and provide a ready-to-use algorithm for many data problems. Our hyperparameter settings are $m = 50$,\footnote{In contrast to \citet{Chipman2010}, we recommend this default as a good starting point rather than $m=200$ due to our experience experimenting with the \qu{RMSE by number of trees} feature found in later in this section. Performance is often similar and computational time and memory requirements are dramatically reduced.} $\alpha = 0.95$, $\beta = 2$, $k = 2$, $q = 0.9$, $\nu = 3$, probabilities of the GROW / PRUNE / CHANGE steps is 39\% / 39\% /44\%. We set the number of burn-in Gibbs samples to 250 and number of post-burn-in samples to 1,000. We default the missing data feature to be off. We default the covariates to be equally important \textit{a priori}. Other parameters and their defaults can be found in the package's online manual. Below is a default \texttt{bartMachine} model. Here, $\X$ denotes automobile attributes and $\y$ denotes the log price of the automobile.

\begin{verbatim}
> bart_machine = build_bart_machine(X, y)
Building BART for regression ... evaluating in sample data...done
\end{verbatim}

If one wishes to see the iterations of the Gibbs sampler of Equation \ref{eq:gibbs_sampler}, the flag \texttt{verbose} can be set to ``TRUE''. One can see more debug information from the \texttt{Java} program by setting the flag \texttt{debug\_log} to true and the program will print to \texttt{unnamed.log} in the current working directory. We now inspect the model object to query its in-sample performance and to be reminded of the input data and model hyperparameters.

\begin{figure}[htp]
\centering
\begin{verbatim}
> bart_machine
Bart Machine v1.0b for regression

training data n = 160 and p = 46 
built in 1 secs on 4 cores, 50 trees, 250 burn in and 1000 post. samples

sigsq est for y beforehand: 0.014 
avg sigsq estimate after burn-in: 0.00886 

in-sample statistics:
 L1 = 9.03 
 L2 = 0.8 
 rmse = 0.07 
 Pseudo-Rsq = 0.9741
p-val for shapiro-wilk test of normality of residuals: 0.01785 
p-val for zero-mean noise: 0.97692
\end{verbatim}
\caption{The summary for the default \texttt{bartMachine} model built with the automobile data}
\label{verbatim:default_bart_summary}
\end{figure}

Since the response was considered continuous, we employ \texttt{BART} for regression. The dimensions of the design matrix are given. Note that we dropped 45 observations that contained missing data (which we will retain in Section \ref{subsec:incorporating_missing_data}).  We then have a recording of the MSE for the OLS model and our average estimate of $\sigsq_e$. We are then given in-sample statistics on error. Pseudo-$R^2$ is calculated via $1 - SSE/SST$. Also provided are outputs from tests of the error distribution being mean centered and normal. In this case, we cannot conclude normality of the residuals using the Shapiro-Wilk test.

We can also obtain out-of-sample statistics to assess level of overfitting by using k-fold cross validation. Using 10 folds we find:

\begin{verbatim}
> k_fold_cv(X, y, k_folds = 10)
$L1_err	         $L2_err           $rmse            $PseudoRsq
[1] 22.63155     [1] 5.202831      [1] 0.1803266    [1] 0.831917
\end{verbatim}

The Pseudo-$R^2$ being lower out-of-sample versus in-sample suggests evidence that \text{BART} is slightly overfitting (note that the training sample during cross-validation is 10\% smaller).

It may also be of interest how the number of trees $m$ affects performance. One can examine how out-of-sample predictions vary by the number of trees via 

\begin{verbatim}
> rmse_by_num_trees(bart_machine, num_replicates = 20)
\end{verbatim}

\noindent and the output is shown in Figure~\ref{fig:rmse_by_trees}.

\begin{figure}[htp]
\centering
\includegraphics[width=3.5in]{rmse_by_trees.pdf}
\caption{Out-of-sample predictive performance by number of trees}
\label{fig:rmse_by_trees}
\end{figure}

It seems that increasing $m > 50$ does not result in any substantial increase in performance. We can now try to build a better \texttt{bartMachine} by grid-searching over a set of hyperparameter combinations, including $m$ \citep[for more details, see BART-cv in][]{Chipman2010}. The default grid search is small and it can be customized by the user.

\begin{verbatim}
> bart_machine_cv = build_bart_machine_cv(X, y)
...
BART CV win: k: 2 nu, q: 10, 0.75 m: 200
\end{verbatim}

This function returns the \qu{winning} model, which is the one with lowest out-of-sample RMSE over a 5-fold cross-validation. Here, the cross-validated \texttt{bartMachine} model has slightly better in-sample performance (L1 = 8.18, L2 = 0.68 and Pseudo-$R^2 = 0.978$) as well as slightly better out-of-sample performance:

\begin{verbatim}
> k_fold_cv(X, y, k_folds = 10, k = 2, nu = 3, q = 0.9, num_trees = 200)
$L1_err          $L2_err          $rmse               $PseudoRsq 
[1] 21.21557     [1] 4.517916     [1] 0.1680386       [1] 0.8540439
\end{verbatim}

\noindent Predictions are handled with the \texttt{predict} function:

\begin{verbatim}
predict(bart_machine_cv, X[1 : 14, ])
   9.479963  9.775766  9.799110 10.050041  9.659138  9.697902  9.873622
   9.931972  8.550436  8.688874  8.794351  8.647986  8.690300  9.029066
\end{verbatim}

\noindent We also include a convenience method \texttt{bart\_predict\_for\_test\_data} that will predict and return out-of-sample error metrics when the test outcomes are known.

\subsection{Model Destroying}\label{subsec:model_destroying}

As noted in the introduction to Section~\ref{sec:package}, \texttt{bartMachine} objects persist in \texttt{Java} for the entirety of an \texttt{R} session. These model objects can use a substantial amount of RAM and it is prudent to release this memory when it is no longer needed. Simply removing a \texttt{bartMachine} in \texttt{R} does \textit{not} destroy the \texttt{Java} object and release the RAM (resulting in a memory leak).

Therefore, we provide a utility function \texttt{destroy\_bart\_machine} that cleans up the \texttt{Java} object. This function should be called when a \texttt{bartMachine} object is no longer needed and \textit{before} removing or overwriting the \texttt{R} variable. Since we no longer are using the original \texttt{bart\_machine} object, we now release its memory via:

\begin{verbatim}
destroy_bart_machine(bart_machine)
\end{verbatim}


\subsection{Assumption Checking}\label{subsec:assumption_checking}

The package includes features that assess the plausibility of the \texttt{BART} model assumptions. Checking the mean-centeredness of the noise is addressed in the summary output of Figure~\ref{verbatim:default_bart_summary} and is simply a one-sample $t$-test of the average residual value against a null hypothesis of true mean zero. We assess both normality and heteroskedasticity via:

\begin{verbatim}
> check_bart_error_assumptions(bart_machine_cv)
\end{verbatim}

This will display a window similar to Figure~\ref{fig:bart_normality_heteroskedasticity} which contains a QQ-plot (to assess normality) as well as a residual-by-predicted plot (to assess homoskedasticity). It appears that the errors are most likely normal and homoskedastic.

\begin{figure}[h]
\centering
\includegraphics[width=5in]{bart_normality_heteroskedasticity.pdf}
\caption{Test of normality of errors using QQ-plot and the Shapiro-Wilk test (top), residual plot to assess heteroskedasticity (bottom).}
\label{fig:bart_normality_heteroskedasticity}
\end{figure}

In addition to the model assumptions, \texttt{BART} requires convergence of its Gibbs sampler. Figure~\ref{fig:convergence_diagnostics} displays four types of convergence diagnostics.

\begin{figure}[htp]
\centering
\includegraphics[width=6.2in]{convergence_diagnostics.pdf}
\caption{Convergence diagnostics for the cross-validated \texttt{bartMachine} model. Top left: $\sigsq$ by Gibbs sample. Samples to the left of the first vertical grey line are burn-in from the first computing core's Gibbs sample chain. The four subsequent plots separated by grey lines are the post-burn-in samples from each of the four computing cores employed during model construction. Top right: percent acceptance of Metropolis-Hastings proposals across the $m$ trees where each point plots one iteration. Points before the grey vertical line illustrate burn-in samples and points after illustrate post burn-in. Each computing core is colored differently. Bottom left: average number of leaves across the $m$ trees by sample (post burn-in only where computing cores separated by vertical grey lines). Bottom right: average tree depth across the $m$ trees by sample (post burn-in only where computing cores separated by vertical grey lines).}
\label{fig:convergence_diagnostics}
\end{figure}

\subsection{Credible Intervals and Prediction Intervals}\label{subsec:credible_and_prediction_intervals}

An advantage of \texttt{BART} is that if we believe the priors and model assumptions, the Bayesian probability model and corresponding burned-in Gibbs samples provide the approximate posterior distribution of $f\parens{\x}$. Thus, one can compute uncertainty estimates via quantiles of the posterior samples. These provide Bayesian \qu{credible intervals} which are intervals for the conditional expectation function, $\cexpe{\y}{\X}$.

Another useful uncertainty interval can be computed for individual predictions by combining uncertainty from the conditional expectation function with the systematic, homoskedastic normal noise produceed by $\errorrv$. Since we have draws from the posterior of the conditional expectation distribution and concomitant draws from the posterior of the variance distribution, we can simulate the distribution of the response by drawing many realizations from $\mathcal{N}(f(\x)_n,\sigsq_n)$ for each the post-burn-in samples and aggregating them. The prediction interval is then provided by the appropriate quantiles of the posterior samples.

Below is an example of how both types of intervals are computed in the package (for the 100th observation of the training data):

\begin{verbatim}
> calc_credible_intervals(bart_machine_cv, X[100, ], ci_conf = 0.95)
     ci_lower_bd ci_upper_bd
[1,]    8.725202    8.971687
> calc_prediction_intervals(bart_machine_cv, X[100, ], pi_conf = 0.95)
     pi_lower_bd pi_upper_bd
[1,]    8.631243     9.06353
\end{verbatim}
 
Note that the prediction intervals are wider than the credible intervals because they reflect the uncertainty from the error term.

We can then plot these intervals in sample:

\begin{verbatim}
> plot_y_vs_yhat(bart_machine_cv, credible_intervals = TRUE)
> plot_y_vs_yhat(bart_machine_cv, prediction_intervals = TRUE)
\end{verbatim}

Figure~\ref{fig:plot_y_vs_y_hat_with_credible_intervals} shows how our prediction fared against the original response (in-sample) with 95\% credible intervals.  Figure~\ref{fig:plot_y_vs_y_hat_with_prediction_intervals} shows the same prediction versus the original response plot now with 95\% prediction intervals. 


\begin{figure}[htp]
\centering
\begin{subfigure}[c]{\textwidth}
                \centering
                \includegraphics[width=3.5in]{plot_y_vs_y_hat_cred_ints.pdf}
                \caption{Segments illlustrate credible intervals}
                \label{fig:plot_y_vs_y_hat_with_credible_intervals}
        \end{subfigure}\\
\begin{subfigure}[c]{\textwidth}
                \centering
                \includegraphics[width=3.5in]{plot_y_vs_y_hat_pred_ints.pdf}
                \caption{Segments illlustrate prediction intervals}
                \label{fig:plot_y_vs_y_hat_with_prediction_intervals}
        \end{subfigure}
\caption{Fitted versus actual response values for the automobile dataset. Segments are 95\% credible intervals (a) or 95\% prediction intervals (b). Green dots indicate the true response is within the stated interval and red dots indicate otherwise. Note that the percent coverage in (a) is not expected to be 95\% because the response includes a noise term.}
\label{fig:plot_y_vs_y_hat}
\end{figure}


\subsection{Variable Importance}\label{subsec:variable_importance}

After a \texttt{BART} model is built, it is natural to ask the question: which variables are most important? This is assessed by examining the splitting rules in the $m$ trees across the post burn-in gibbs samples which are known as \qu{inclusion proportions} \citep{Chipman2010}. The inclusion proportion for any given predictor represents the proportion of times that variable is chosen as a spliting rule out of all splitting rules among the posterior draws of the sum-of-trees model. Figure~\ref{fig:var_imp_automobile_cc} illustrates the inclusion proportions for all variables obtained via:

\begin{verbatim}
> investigate_var_importance(bart_machine_cv, num_replicates_for_avg = 20)
\end{verbatim}

\begin{figure}[htp]
\centering
\includegraphics[width=5.9in]{var_imp_automobile_cc.pdf}
\caption{Average variable inclusion proportions in the cross-validated \texttt{bartMachine} model for the automobile data averaged over 100 model constructions to obtain stable estimates across many posterior modes in the sum-of-trees distribution (as recommended in \citealp{Bleich2013}). The segments atop the bars represent 95\% confidence intervals. The eight predictors with inclusion proportions of zero feature identically one value (after missing data was dropped).}
\label{fig:var_imp_automobile_cc}
\end{figure}

Actual selection of variables \textit{significantly} affecting the response is addressed conceptually in Section~\ref{subsec:variable_selection} and examples are provided in Section~\ref{subsec:variable_selection_regression}.

\subsection{Variable Effects}\label{subsec:variable_effects}

It is also natural to ask: does $\x_j$ affect the response, controlling for other variables in the model? This is roughly analogous to the $t$-test in ordinary least squares regression of no linear effect of $\x_j$ on $\y$ while controlling for $\x_{-j}$. The null hypothesis here is the same but the linearity constraint is relaxed. To test this, we employ a permutation approach where we record the observed Pseudo-$R^2$ from the \texttt{bartMachine} model built with the original data. Then we permute the $\x_j$th column, thereby destroying any relationship between $\x_j$ and $\y$, construct a new duplicate \texttt{bartMachine} model from this permuted design matrix and record a ``null'' Pseudo-$R^2$. We then repeat this  process to obtain a null distribution of Pseudo-$R^2$'s. Since the alternative hypothesis is that $\x_j$ has an effect on $\y$ in terms of predictive power, our $\pval$ is the proportion of null Pseudo-$R^2$'s greater than the observed Pseudo-$R^2$, making our procedure a natural one-sided test. Note, however, that this test is conditional on the \texttt{BART} model and its selected priors being true, similar to the assumptions of the linear model. 

If we wish to test if a set of covariates $A \subset \braces{\x_{1}, \ldots, \x_{p}}$ affect the response after controlling for other variables, we repeat the procedure outlined in the above paragraph by permuting the columns of $A$ in every null sample. This is roughly analogous to the partial $F$-test in ordinary least squares regression. 

If we wish to test if \textit{any} of the covariates matter in predicting $\y$, roughly analogous to the omnibus $F$-test in ordinary least squares regression, we simply permute $\y$ during the null sampling. This procedure breaks the relationship between the response and the predictors but does not alter the existing associations between predictors.

At $\alpha = 0.05$, Figure~\ref{fig:cov_test_width} demonstrates an insignificant effect of the variable \texttt{width} of car on price. Even though \texttt{width} is putatively the \qu{most important} variable as measured by proportions of splits in the posterior sum-of-trees model (Figure~\ref{fig:var_imp_automobile_cc}), note that this is largely an easy prediction problem with many collinear predictors. Figure~\ref{fig:cov_test_body_style} shows the results of a test of the putatively most important categorical variable, \texttt{body style} (which involves permuting the categories, then dummifying the levels to preserve the structure of the variable). We find a marginally significant effect ($p = 0.0495$). A test of the top ten most important variables is convincingly significant (Figure~\ref{fig:cov_test_top_10}). For the omnibus test, Figure~\ref{fig:cov_test_omnibus} illustrates an extremely statistically significant result, as would be expected. The code to run these tests is shown below (output suppressed).

\begin{verbatim}
> cov_importance_test(bart_machine_cv, covariates = c("width"))
> cov_importance_test(bart_machine_cv, covariates = c("body_style"))
> cov_importance_test(bart_machine_cv, covariates = c("width",
  "curb_weight", "city_mpg", "length", "horsepower", "body_style", 
  "engine_size", "highway_mpg", "peak_rpm", "normalized_losses"))
> cov_importance_test(bart_machine_cv)
\end{verbatim}

\begin{figure}[h]
\centering
\begin{subfigure}[c]{0.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{cov_test_width.pdf}
                \caption{\texttt{width}}
                \label{fig:cov_test_width}
        \end{subfigure}~~
\begin{subfigure}[c]{0.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{cov_test_body_style.pdf}
                \caption{\texttt{body style}}
                \label{fig:cov_test_body_style}
        \end{subfigure}\\
\begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{cov_test_top_10.pdf}
                \caption{The 10 most split-on variables}
                \label{fig:cov_test_top_10}
        \end{subfigure}~~
\begin{subfigure}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{cov_test_omnibus.pdf}
                \caption{All covariates}
                \label{fig:cov_test_omnibus}
        \end{subfigure}
\caption{Tests of covariate importance conditional on the cross-validated \texttt{bartMachine} model. All tests performed with 100 null samples.}
\label{fig:cov_tests}
\end{figure}

\subsection{Partial Dependence}\label{subsec:partial_dependence}

A data analyst may also be interested in understanding how $\x_j$ affects the response on average, after controlling for other predictors. This can be examined using \citet{Friedman2001}'s Partial Dependence Function (PDP),

\bneqn\label{eq:true_pdp}
f_j(\x_j) = \expesub{\x_{-j}}{f(\x_j,\x_{-j})} = \int f(\x_j,\x_{-j}) \mathrm{dP}\parens{\x_{-j}},
\eneqn

\noindent where $\x_{-j}$ denotes all variables except $\x_j$. The PDP of predictor $\x_j$ gives the average value of $f$ when $\x_j$ is fixed and $\x_{-j}$ varies over its marginal distribution, $\mathrm{dP}\parens{\x_{-j}}$. As neither the true model $f$ nor the distribution of the predictors $\mathrm{dP}\parens{\x_{-j}}$ are known, we estimate Equation~\ref{eq:true_pdp} by computing

\bneqn\label{eq:est_pdp}
\hat{f}_j(\x_j) = \frac{1}{n}\sum\limits_{i=1}^n \hat{f}(\x_{j},\x_{-j,i})
\eneqn

\noindent where $n$ is the number of observations in the training data and $\hat{f}$ denotes the \texttt{bartMachine} model. Since \texttt{BART} provides an estimated posterior distribution, we can plot credible bands for the PDP function. In Equation~\ref{eq:est_pdp}, the $\hat{f}$ can be replaced with a function that calculates the $q$th quantile of the post-burned-in Gibbs samples for $\yhat$. Figure~\ref{fig:pdp_horsepower} plots the PDP along with the 2.5\%ile and the 97.5\%ile for the variable \texttt{horsepower}. By varying over most of the range of \texttt{horsepower}, the price is predicted to increase by about \$1000. Figure~\ref{fig:pdp_stroke} plots the PDP along with the 2.5\%ile and the 97.5\%ile for the variable \texttt{stroke}. This predictor seemed to be relatively unimportant according to Figure~\ref{fig:var_imp_automobile_cc} and the PDP confirms this, with a very small, yet nonlinear average partial effect. The code for both plots is below.

\begin{verbatim}
> pd_plot(bart_machine_cv, j = "horsepower")
> pd_plot(bart_machine_cv, j = "stroke")
\end{verbatim}


\begin{figure}[htp]
\centering
\begin{subfigure}[c]{0.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{pdp_horsepower.pdf}
                \caption{\texttt{horsepower}}
                \label{fig:pdp_horsepower}
        \end{subfigure}~~
\begin{subfigure}[c]{0.48\textwidth}
                \centering
                \includegraphics[width=3.2in]{pdp_stroke.pdf}
                \caption{\texttt{stroke}}
                \label{fig:pdp_stroke}
        \end{subfigure}
\caption{PDPs plotted in black and 95\% credible intervals plotted in blue for variables in the automobile dataset. Points plotted are at the 5\%ile, 10\%ile, 20\%ile, \ldots, 90\%ile and 95\%ile of the values of the predictor. Lines plotted between the points approximate the PDP by linear interpolation.}
\label{fig:pdps}
\end{figure}

\subsection{Incorporating Missing Data}\label{subsec:incorporating_missing_data}

The procedure for incorporating missing data was introduced in Section~\ref{subsec:missing_data}. We now build a \texttt{bartMachine} model using this procedure below:

\begin{verbatim}
> #reload data with missingness intact
> data(automobile)
> y = automobile$price
> X = automobile; X$price = NULL
> bart_machine = build_bart_machine(X, y, use_missing_data = TRUE, 
      use_missing_data_dummies_as_covars = TRUE)
> bart_machine
Bart Machine v1.0b for regression

Missing data feature ON
training data n = 201 and p = 50 
built in 1.3 secs on 1 core, 50 trees, 250 burn-in and 1000 post. samples

sigsq est for y beforehand: 0.016 
avg sigsq estimate after burn-in: 0.01055 

in-sample statistics:
 L1 = 12.77 
 L2 = 1.28 
 rmse = 0.08 
 Pseudo-Rsq = 0.9746
p-val for shapiro-wilk test of normality of residuals: 0.6638 
p-val for zero-mean noise: 0.95693 
\end{verbatim}

Note that we now use the complete data set including the 41 observations for which there were missing features. Also note that $p$ has now increased from 46 to 51. The five new predictors are dummy variables which indicate missingness constructed from the predictors which exhibited missingness (due to the \texttt{use\_missing\_data\_dummies\_as\_covars} parameter being set to true). These variables are important if missingness \textit{itself} shifts the response, as was the case in models explored in \cite{Kapelner2013}. One way to test if this type of missingness is important is to run a covariate test (Section~\ref{subsec:variable_effects}) on these new 5 covariates:

\begin{verbatim}
> cov_importance_test(bart_machine, covariates = c("M_normalized_losses", 
     "M_bore", "M_stroke", "M_horsepower", "M_peak_rpm"))
BART test for importance of 5 covariates....p_val = 0.673
\end{verbatim}

From the $p$-value, we cannot conclude that these variables have an effect on the response. This seems reasonable given that only 5 predictors featured missingness among only 40 observations. This suggests that it may be appropriate to shrink the model by leaving out these missing dummies, but still allow for missingness to be incorporated into the split rules:

\begin{verbatim}
> bart_machine = build_bart_machine(X, y, use_missing_data = TRUE)
\end{verbatim}

The procedure of Section~\ref{subsec:missing_data} also natively incorporates missing data during prediction. Missingness will yield larger credible intervals. In the example below, we suppose that the \texttt{curb\_weight} and \texttt{symboling} values were unavailable for 20th automobile.

\begin{verbatim}
> x_star = X[20, ]
> calc_credible_intervals(bart_machine, x_star, ci_conf = 0.95)
     ci_lower_bd ci_upper_bd
[1,]    8.650093    8.824515
> x_star[c("curb_weight", "symboling")] = NA
> calc_credible_intervals(bart_machine, x_star, ci_conf = 0.95)
     ci_lower_bd ci_upper_bd
[1,]    8.622582    8.978313
\end{verbatim}

\subsection{Variable Selection}\label{subsec:variable_selection_regression}

In this section we demonstrate the principled variable selection procedure introduced in Section~\ref{subsec:variable_selection}. The following code will select variables based on the three thresholds and also displays the plot in Figure~\ref{fig:var_selection_plot}.\footnote{By default, variable selection is performed individually on dummy variables for a factor. The variable selection procedures return the permutation distribution and an aggregation of the dummy variables' inclusion proportions can allow for variable selection to be performed on an entire factor.}

\begin{verbatim}
> vs = var_selection_by_permute_response_three_methods(bart_machine, 
            bottom_margin = 10, num_permute_samples = 10)
> vs$important_vars_local_names
  "curb_weight"  "city_mpg" "engine_size"   "horsepower"            
  "length"       "width"    "num_cylinders" "body_style_convertible"
  "wheel_base"   "peak_rpm" "highway_mpg"   "wheel_drive_fwd"       
> vs$important_vars_global_max_names
  "curb_weight" "city_mpg"    "engine_size" "horsepower"  "length"     
> vs$important_vars_global_se_names
  "curb_weight"   "city_mpg"      "engine_size" "horsepower" "length"           
  "width"         "num_cylinders" "wheel_base"  "wheel_drive_fwd"
\end{verbatim}

\begin{figure}[htp]
\centering
\includegraphics[width=6in]{var_selection_plot.pdf}
\caption{Visualization of the three variable selection procedures outlined in Section~\ref{subsec:variable_selection} with $\alpha = 0.05$. The top plot illustrates the ``Local'' procedure. The green lines are the threshold levels determined from the permutation distributions that must be exceeded for a variable to be selected. The plotted points are the variable inclusion proportions for the observed data (averaged over five duplicate \texttt{bartMachine} models). If the observed value is higher than the green bar, the variable is included and is displayed as a solid dot; if not, it is not included and it is displayed as an open dot. The bottom plot illustrates both the ``Global SE'' and ``Global Max'' thresholds. The red line is the cutoff for ``Global Max'' and variables pass this threshold are displayed as solid dots. The blue lines represent the thresholds for the ``Global SE'' procedure. Variables that exceed this cutoff but not the ``Global Max'' threshold are displayed as asterisks. Open dots exceed neither threshold.}
\label{fig:var_selection_plot}
\end{figure}

Usually,  ``Global Max'' and ``Global SE'' perform similarly, as they are both more stringent in selection. However, in many situations it will not be clear to the data analyst which threshold is most appropriate. The ``best'' procedure can be chosen via cross-validation on out-of-sample RMSE as follows: 

\begin{verbatim}
var_selection_by_permute_response_cv(bart_machine)
$best_method
[1] "important_vars_local_names"

$important_vars_cv
 [1] "body_style_convertible" "city_mpg"               "curb_weight"           
 [4] "engine_size"            "engine_type_ohc"        "horsepower"            
 [7] "length"                 "num_cylinders"          "peak_rpm"              
[10] "wheel_base"             "wheel_drive_fwd"        "wheel_drive_rwd"       
[13] "width" 
\end{verbatim}

On this dataset, the \qu{best} approach (as defined by out-of-sample prediction error) is the ``Local'' procedure.\\

The following sections (\ref{subsec:cov_prior} and \ref{subsec:interaction_detection}) demostrate additional features using \citet{Friedman1991}'s function:

\bneqn\label{eq:friedman}
\y = 10\sin{\pi\x_1\x_2}+20(\x_3-.5)^2+10\x_4+5\x_5 + \berrorrv, \qquad \berrorrv \sim \multnormnot{n}{\0}{\sigsq\bv I}.
\eneqn

\subsection{Informed Prior Information on Covariates}\label{subsec:cov_prior}

\citet{Bleich2013} propose a method for incorporating informed prior information about the predictors into \texttt{BART}. This can be achieved by modifying the prior on the splitting rules as well as the corresponding calculations in the Metropolis-Hastings step. In particular, covariates believed to influence the response can be proposed more often as candidates for splitting rules. Useful prior information can aid in both variable selection and prediction tasks. We illustrate the impact of a correctly informed prior in the context of the Friedman function (Equation~\ref{eq:friedman}). We include the 5 predictors which influence the response as well as 95 that do not.

All that is required is a specification of relative weights for each predictor. These are converted internally to probabilities. We assign 5 times the weight to the 5 true covariates of the model relative to the 95 useless covariates.

\begin{verbatim}
> prior = c(rep(5, times = 5), rep(1, times = 95))
\end{verbatim}

We now sample 500 observations from the Friedman function and construct a default \texttt{bartMachine} model as well as a \texttt{bartMachine} model with the informed prior and compare their performance on a test set of another 500 observations.

\begin{verbatim}
> bart_machine = build_bart_machine(X, y)
> bart_machine_informed = build_bart_machine(X, y, cov_prior_vec = prior)

> bart_predict_for_test_data(bart_machine, Xtest, ytest)$rmse
[1] 1.661159
> bart_predict_for_test_data(bart_machine_informed, Xtest, ytest)$rmse
[1] 1.232925
\end{verbatim}

There is a substantial improvement in out-of-sample predictive performance when a properly informed prior is used. 

Note that we recommend use of the prior vector to down-weight the indicator variables that result from dummifying factors so that the total set of dummy variables has the same weight as a continuous covariate.

\subsection{Interaction Effect Detection}\label{subsec:interaction_detection}

In Section~\ref{subsec:variable_importance}, we explored using variable inclusion proportions to understand the relative influences of different covariates. A similar procedure can be carried out for examining interaction effects within a \texttt{BART} model. This question was initially explored in \citet{Damien2013} where an interaction was considered to exist between two variables if they both appeared in at least one splitting rule in a given tree. We refine the definition of an interaction as follows. 

We first begin with a $p \times p$ matrix of zeroes. Within a given tree, for each split rule variable $j$, we look at all split rule variables of child nodes, $k$, and we increment the $j, k$ element of the matrix. Hence variables are considered to interact in a given tree \textit{only if} they appear together in a contiguous downward path from the root node to a terminal node.  Note that a variable may interact with itself (when fitting a linear effect, for instance). Since there is no order between the parent and child, we then add the $j, k$ counts together with the $k, j$ counts (if $j \neq k$). Summing across trees and Gibbs samples gives the total number of interactions for each pair of variables from which relative importance can be assessed. 

We demonstrate interaction detection on the Friedman function using 10 covariates using the code below: 

\begin{verbatim}
> interaction_investigator(bart_machine, num_replicates_for_avg = 25, 
      num_var_plot = 10, bottom_margin = 5)
\end{verbatim}

Shown in Figure~\ref{fig:friedman_function_interactions} are the ten most important interactions in the model. The illustration is averaged over many model constructions to obtain stable estimates across many posterior modes in the sum-of-trees distribution. Notice that the interaction between $\x_1$ and $\x_2$ dominates all other terms, as \texttt{BART} is correctly capturing the single true interaction effect in Equation~\ref{eq:friedman}. Choosing which of these interactions \textit{significantly} affect the response is not addressed in this paper. The methods suggested in Section~\ref{subsec:variable_selection} may be applicable here and we consider this to be fruitful future work.

\begin{figure}[htp]
\centering
\includegraphics[width=4in]{friedman_function_interactions.pdf}
\caption{The top 10 average variable interaction counts (termed \qu{relative importance}) in the default \texttt{bartMachine} model for the Friedman function data averaged over 25 model constructions. The segments atop the bars represent 95\% confidence intervals.}
\label{fig:friedman_function_interactions}
\end{figure}


\section{Classification Features}\label{sec:classification_features}

In this section we highlight the features that differ from the regression case when the response is dichotomous. The illustrative dataset consists of 332 Pima Indians obtained from the UCI repository. Of the 332 subjects, 109 were diagnosed with diabetes, the binary response variable. There are seven continuous predictors which are body metrics such as blood pressure, glucose concentration, etc. and there is no missing data. 
	
Building a \texttt{bartMachine} model for classification has the same computing parameters except that $q, \nu$ cannot be specified since there is no longer a prior on $\sigsq$ (see Section~\ref{subsec:probit_bart}). We first build a cross-validated model below.

\begin{verbatim}
> bart_machine_cv = build_bart_machine_cv(X, y)
... BART CV win: k: 3 m: 50
> bart_machine_cv
Bart Machine v1.0b for classification

training data n = 332 and p = 7 
built in 0.5 secs on 4 cores, 50 trees, 250 burn-in and 1000 post. samples

confusion matrix:

           predicted No predicted Yes model errors
actual No       211.000         12.00        0.054
actual Yes       41.000         68.00        0.376
use errors        0.163          0.15        0.160
\end{verbatim}

Classification models have an added hyperparameter, \texttt{prob\_rule\_class}, which is the rule for determining if the probability estimate is great enough to be classified into the positive category. We can see above that the \texttt{bartMachine} at times predicts ``NO'' for true ``YES'' outcomes and we suffer from a 37.6\% error rate for this outcome. We can try to mitigate this error by lowering the threshold to increase the number of ``YES'' labels predicted:

\begin{verbatim}
> build_bart_machine(X, y, prob_rule_class = 0.3)
Bart Machine v1.0b for classification

training data n = 332 and p = 7 
built in 0.5 secs on 4 cores, 50 trees, 250 burn-in and 1000 post. samples

confusion matrix:

           predicted No predicted Yes model errors
actual No       178.000        45.000        0.202
actual Yes       12.000        97.000        0.110
use errors        0.063         0.317        0.172
\end{verbatim}

This lowers the model error to 11\% for the ``YES'' class, but at the expense of increasing the error rate for the ``NO'' class. We encourage the user to cross-validate this rule based on the appropriate objective function for the problem at hand.

We can also check out-of-sample statistics:

\begin{verbatim}
> oos_stats = k_fold_cv(X, y, k_folds = 10)
> oos_stats$confusion_matrix
           predicted No predicted Yes model errors
actual No       203.000        20.000        0.090
actual Yes       47.000        62.000        0.431
use errors        0.188         0.244        0.202
\end{verbatim}

\noindent Note that it is possible to predict both class labels and probability estimates for given observations:

\begin{verbatim}
> predict(bart_machine_cv, X[1 : 2, ], type = "prob")
[1] 0.6253160 0.1055975
> predict(bart_machine_cv, X[1 : 2, ], type = "class")
[1] "Yes" "No" 
\end{verbatim}

When using the covariate tests of Section~\ref{subsec:variable_effects},total misclassification error becomes the statistic of interest instead of Pseudo-$R^2$. The $p$ value is calculated now as the proportion of null samples with \textit{higher} misclassification error. Figure~\ref{fig:covariate_test_age} illustrates the test showing that predictor \texttt{age} seems to matter in the prediction of \texttt{Diabetes}, controlling for other predictors.

\begin{figure}[h]
\centering
\includegraphics[width=3.7in]{covariate_test_age.pdf}
\caption{Test of covariate importance for predictor \texttt{age} on whether or not the subject will contract \texttt{Diabetes}.}
\label{fig:covariate_test_age}
\end{figure}



The partial dependence plots of Section~\ref{subsec:partial_dependence} are now scaled as probit of the probability estimate. Figure~\ref{fig:glucose_partial_dependence} illustrates that as glucose increases, the probability of contracting \texttt{Diabetes} increases linearly on a probit scale.

\begin{figure}[h]
\centering
\includegraphics[width=3.0in]{glucose_partial_dependence.pdf}
\caption{PDP for predictor \texttt{glu}. The blue lines are 95\% credible intervals.}
\label{fig:glucose_partial_dependence}
\end{figure}

Credible intervals are implemented for classification \texttt{bartMachine} and are displayed on the probit scale. Note that the prediction intervals of Section~\ref{subsec:credible_and_prediction_intervals} do not exist for classification.

\begin{verbatim}
> calc_credible_intervals(bart_machine_cv, X[1 : 2, ])
     ci_lower_bd ci_upper_bd
[1,]  0.34865355   0.8406097
[2,]  0.01686486   0.2673171
\end{verbatim}

Other functions work similarly to regression except those that plot the responses and those that explicitly depend on RMSE as an error metric.


\section{Discussion}\label{sec:discussion}

This article introduced \texttt{bartMachine}, a new \texttt{R} package which implements Bayesian Additive Regression Trees. The goal of this package is to provide a fast, extensive and user-friendly implementation accessible to a wide range of data analysts, and increase the visibility of \texttt{BART} to a broader statistical audience. We hope we have provided organized, well-documented open-source code and we encourage the community to make innovations on this package.

\subsection*{Replication}

The code for \texttt{bartMachine} is located at \url{http://github.com/kapelner/bartMachine} under the MIT license. Results, tables, and figures found in this paper can be replicated via the scripts located in the \texttt{bart\_package\_paper} folder within this \texttt{git} repository.

\subsection*{Acknowledgements}

We thank Richard Berk, Andreas Buja, Zachary Cohen, Ed George, Alex Goldstein, Shane Jensen, Abba Krieger, and Robert DeRubeis for helpful discussions. We thank Simon Urbanek for his generous help with \texttt{rJava}. Adam Kapelner acknowledges support from the National Science Foundation's Graduate Research Fellowship Program.

\bibliographystyle{plainnat}
\bibliography{bart_package_paper}


\appendix
\section{Sampling New Trees}\label{app:implementation}

This section provides details on the implementation of Equation~\ref{eq:gibbs_sampler} (steps 1, 3, \ldots, $2m-1$), the Metropolis-Hastings step for sampling new trees.  Recall from Section~\ref{subsec:posterior} that trees can be altered via growing new daughter nodes from an existing terminal node, pruning two terminal nodes such that their parent becomes terminal, or changing the splitting rule in a node. 

Below is the Metropolis ratio \citep[p.291]{Gelman2004} where the parameter sampled is the tree and the data is the responses unexplained by other trees denoted by $\R$. We denote the new, proposal tree with an asterisk and the original tree without the asterisk.

\bneqn\label{eq:naive_metropolis}
r = \frac{\prob{\treet{*} \rightarrow \treet{}}}{\prob{\treet{} \rightarrow \treet{*}}} \frac{\cprob{\treet{*}}{\R, \sigsq}}{\cprob{\treet{}}{\R, \sigsq}}
\eneqn

We accept a draw from the posterior distribution of trees if a draw from a standard uniform distribution is less than the value of $r$. Immediately we note that it is difficult (if not impossible) to calculate the posterior probabilities for the trees themselves. Instead, we employ Bayes' Rule, 

\beqn
\cprob{\treet{}}{\R, \sigsq} = \frac{\cprob{\R}{\treet{}, \sigsq} \cprob{\treet{}}{\sigsq}}{\cprob{\R}{\sigsq}},
\eeqn

and plug the result into Equation~\ref{eq:naive_metropolis} to obtain:

\beqn
r &=& \underbrace{\frac{\prob{\treet{*} \rightarrow \treet{}}}{\prob{\treet{} \rightarrow \treet{*}}}}_{\text{transition ratio}} ~~~\times~~~ \underbrace{\frac{\cprob{\R}{\treet{*}, \sigsq}}{\cprob{\R}{\treet{}, \sigsq}}}_{\text{likelihood ratio}} ~~~\times \underbrace{\frac{\prob{\treet{*}}}{\prob{\treet{}}}}_{\text{tree structure ratio}}.
\eeqn

\noindent Note that the probability of the tree structure is independent of $\sigsq$. 

The goal of this section is to explicitly calculate $r$ for all possible tree proposals --- GROW, PRUNE and CHANGE. For each proposal, the calculations are organized into separate sections detailing each of the three ratios --- transition, likelihood and tree structure. Note that our actual implementation uses the following expressions in log form for numerical accuracy.

\subsection{Grow Proposal}\label{subapp:grow_step}

\subsubsection*{Transition Ratio}

Transitioning from the original tree to a new tree involves growing two daughter nodes from a current terminal node:

\bneqn\label{eq:grow_transition}
\prob{\treet{} \rightarrow \treet{*}} &=& \prob{\text{GROW}} \prob{\text{selecting $\eta$ to grow from}} \times \\ \nonumber
&& \prob{\text{selecting the $j$th attribute to split on}} \times \\ \nonumber
&& \prob{\text{selecting the $i$th value to split on}} \\ \nonumber
&=& \prob{\text{GROW}} \oneover{b} \oneover{\padjeta} \frac{1}{\nadjeta}.
\eneqn

We chose one of the current $b$ terminal nodes which we denote the $\eta$th node, and then we pick an attribute and split point. $\padjeta$ denotes the number of predictors left available to split on. This can be less than $p$ if certain predictors do not have two or more unique values once the data reaches the $\eta$th node. For example, this regularly occurs if a dummy variable was split on in some node higher up in the lineage. $\nadjeta$ denotes the number of \textit{unique} values left in the $p$th attribute after adjusting for parents' splits.

Transitioning from the new tree back to the original tree involves pruning that node:

\beqn
\prob{\treet{*} \rightarrow \treet{}} = \prob{\text{PRUNE}} \prob{\text{selecting $\eta$ to prune from}} =  \prob{\text{PRUNE}}\oneover{w_2^*}
\eeqn

\noindent where $w_2^*$ denotes the number of second generation internal nodes (nodes with two terminal daughter nodes) in the new tree. Thus, the full transition ratio is:

\beqn
\frac{\prob{\treet{*} \rightarrow \treet{}}}{\prob{\treet{} \rightarrow \treet{*}}} = \frac{\prob{\text{PRUNE}}}{\prob{\text{GROW}}} \frac{b ~ \padjeta ~ \nadjeta}{w_2^*}.
\eeqn

Note that when there are no variables with more two or more unique values, the probability of GROW is set to zero and the step will be automatically rejected.

\subsubsection*{Likelihood Ratio}

To calculate the likelihood, the tree structure determines which responses fall into which of the $b$ terminal nodes. Thus,

\beqn
\cprob{\Roneton}{\treet{}, \sigsq} = \prod_{\ell=1}^{b} \cprob{\Rlonetonl}{\sigsq}
\eeqn

\noindent where each term on the right hand side is the probability of responses in one of the $b$ terminal nodes, which are independent by assumption. The $R_\ell$'s denote the data in the $\ell$th terminal node and where $n_\ell$ denotes how many observations are in each terminal node and $n = \sum_{\ell=1}^b n_\ell$. 

We now find an analytic expression for the node likelihood term. Remember, if the mean in each terminal node, which we denote $\mu_\ell$, was known, then we would have \\ $\Rlonetonl \,|\, \mu_\ell, \sigsq ~\iid~ \normnot{\mu_\ell}{\sigsq}$. \texttt{BART} requires $\mu_\ell$ to be margined out, allowing the Gibbs sampler in Equation~\ref{eq:gibbs_sampler} to avoid dealing with jumping between continuous spaces of varying dimensions \citep[page 275]{Chipman2010}. Recall that one of the \texttt{BART} model assumptions is a prior on the average value of $\mu \sim \normnot{0}{\sigsq_\mu}$ and thus,

\beqn
\cprob{\Rlonetonl}{\sigsq} = \int_\reals \cprob{\Rlonetonl}{\mu_\ell, \sigsq} \prob{\mu_\ell; \sigsq_\mu} d\mu_\ell
\eeqn

\noindent which can be shown via completion of the square or convolution to be

\bneqn\label{eq:likelihood_margined}
\cprob{\Rlonetonl}{\sigsq} &=& \oneover{\tothepow{2\pi\sigsq}{n_\ell / 2}} \sqrt{ \frac{\sigsq}{\sigsq + n_\ell \sigsqmu}}  \times \\ 
&& \exp{-\oneover{2\sigsq} \parens{\sum_{i=1}^{n_\ell} \squared{R_{\ell_i} - \Rbar_\ell} - \frac{\Rbar_\ell^2 n_\ell^2}{n_\ell + \frac{\sigsq}{\sigsqmu}}+ n_\ell \Rbar_\ell^2}} \nonumber
\eneqn

\noindent where $\Rbar_\ell$ denotes the mean response in the node and $R_{\ell_i}$ denotes the observations $i=1\ldots n_\ell$ in the node.

Since the likelihoods are solely determined by the terminal nodes, the proposal tree differs from the original tree by only the selected node to be grown, denoted by $\ell$, which becomes two daughters after the GROW step denoted by $\ell_L$ and $\ell_R$. Hence, the likelihood ratio becomes:

\bneqn\label{eq:grow_likelihood_ratio}
&& \frac{\cprob{\R}{\treet{*}, \sigsq}}{\cprob{\R}{\treet{}, \sigsq}} = \frac{\cprob{\RLlonetonlL}{\sigsq} \cprob{\RRlonetonlR}{\sigsq}}{\cprob{\Rlonetonl}{\sigsq}} 
\eneqn

Plugging Equation~\ref{eq:likelihood_margined} into Equation~\ref{eq:grow_likelihood_ratio} three times yields the ratio for the GROW step:

\small
\beqn
 \sqrt{\frac{\sigsq \parens{\sigsq + n_\ell \sigsqmu}}{\parens{\sigsq + n_{\ell_L} \sigsqmu}\parens{\sigsq + n_{\ell_R} \sigsqmu}}}~~\exp{\frac{\sigsq_\mu}{2\sigsq} \parens{\frac{\squared{\sum_{i=1}^{n_{\ell_L}} R_{\ell_L, i}}}{\sigsq + n_{\ell_L}\sigsq_\mu} + \frac{\squared{\sum_{i=1}^{n_{\ell_R}} R_{\ell_R, i}}}{\sigsq + n_{\ell_R}\sigsq_\mu} - \frac{\squared{\sum_{i=1}^{n_{\ell}} R_{\ell, i}}}{\sigsq + n_\ell \sigsq_\mu}}} \\
\eeqn
\normalsize

\noindent where $n_{\ell_L}$ and $n_{\ell_R}$ denote the number of data points in the newly grown left and right daughter nodes.

\subsubsection*{Tree Structure Ratio}

In Section~\ref{subsec:prior_likelihood} we discussed the prior on the tree structure (where the splits occur) as well as the tree rules. For the entire tree,

\beqn
\prob{\treet{}} &=& \prod_{\eta \in \Hterminals} \parens{1 - \probsplit{\eta}}  \prod_{\eta \in \Hint} \probsplit{\eta} \prod_{\eta \in \Hint} \probrule{\eta} \\
\eeqn

\noindent where $\Hterminals$ denotes the set of terminal nodes and $\Hint$ denotes the internal nodes.

Recall that the probability of splitting on a given node $\eta$ is $\probsplit{\eta} = \alpha / \tothepow{1 + d_\eta}{\beta}$. The probability is controlled by two hyperparameters, $\alpha$ and $\beta$, and $d_\eta$ is the depth (number of parent generations) of node $\eta$. When assigning  a rule, recall that \texttt{BART} picks from all available attributes and then from all available unique split points. Using the notation from the transition ratio section, $\probrule{\eta} = 1 / \padjeta \times 1 / \nadjeta$.

Once again, the original tree features a node $\eta$ that was selected to be grown. The proposal tree differs with two daughter nodes denoted $\eta_L$ and $\eta_R$. We can now form the ratio:

\beqn
\frac{\prob{\treet{*}}}{\prob{\treet{}}} &=& \frac{\parens{1 - \probsplit{\eta_L}} \parens{1 - \probsplit{\eta_R}} \probsplit{\eta} \probrule{\eta}}{\parens{1 - \probsplit{\eta}}}\\
&=& \frac{\parens{1 - \dfrac{\alpha}{\tothepow{1 + d_{\eta_L}}{\beta}}}\parens{1 - \dfrac{\alpha}{\tothepow{1 + d_{\eta_R}}{\beta}}} \dfrac{\alpha}{\tothepow{1 + d_{\eta}}{\beta}} \doneover{\padjeta}\dfrac{1}{\nadjeta}}{1 -\frac{\alpha}{\tothepow{1 + d_{\eta}}{\beta}}} \\
&=& \alpha \frac{\squared{1 - \frac{\alpha}{\tothepow{2 + d_\eta}{\beta}}}}{\parens{\tothepow{1+d_\eta}{\beta} - \alpha} \padjeta \nadjeta}
\eeqn

The last line follows from algebra and using the fact that the depth of the grown nodes is the depth of the parent node incremented by one ($d_{\eta_L} = d_{\eta_R} = d_{\eta} + 1$).

\subsection{Prune Proposal}\label{subapp:prune_step}

A prune proposal is the \qu{opposite} of a grow proposal. Prune selects a node with two daughters and removes them. Thus, each ratio will be approximately the inverse of the ratios found in the previous section concerning the grow proposal. Note also that prune steps are not considered in trees that consist of a single root node.

\subsubsection*{Transition Ratio}

We begin with transitioning from the original tree to the proposal tree:

\beqn
\prob{\treet{} \rightarrow \treet{*}} = \prob{\text{PRUNE}} \prob{\text{selecting $\eta$ to prune from}} =  \prob{\text{PRUNE}}\oneover{w_2}
\eeqn

\noindent where $w_2$ denotes the number of parent nodes that have two daughters but no grand-daughters. To transition in the opposite direction, we are obligated to grow from node $\eta$. This is similar to Equation~\ref{eq:grow_transition} except the proposed tree has one less terminal node due to the pruning of the original tree, resulting in a  $1 / (b-1)$ term:

\beqn
\prob{\treet{*} \rightarrow \treet{}} &=&  \prob{\text{GROW}} \oneover{b-1} \oneover{\padjetastar} \frac{1}{\nadjetastar}.
\eeqn

Thus, the transition ratio is:

\beqn
\frac{\prob{\treet{*} \rightarrow \treet{}}}{\prob{\treet{} \rightarrow \treet{*}}} = \frac{\prob{\text{GROW}}}{\prob{\text{PRUNE}}} \frac{w_2 }{(b-1) \padjetastar \nadjetastar}.
\eeqn

\subsubsection*{Likelihood Ratio}

This is simply the inverse of the likelihood ratio for the grow proposal:

\beqn
\frac{\cprob{\R}{\treet{*}, \sigsq}}{\cprob{\R}{\treet{}, \sigsq}} &=&  \sqrt{\frac{\parens{\sigsq + n_{\ell_L} \sigsqmu}\parens{\sigsq + n_{\ell_R} \sigsqmu}}{\sigsq \parens{\sigsq + n_\ell \sigsqmu}}} \times \\
&& \exp{\frac{\sigsq_\mu}{2\sigsq} \parens{\frac{\squared{\sum_{i=1}^{n_{\ell_{~}}} R_{\ell, i}}}{\sigsq + n_\ell \sigsq_\mu} - \frac{\squared{\sum_{i=1}^{n_{\ell_L}} R_{\ell_L, i}}}{\sigsq + n_{\ell_L}\sigsq_\mu} - \frac{\squared{\sum_{i=1}^{n_{\ell_R}} R_{\ell_R, i}}}{\sigsq + n_{\ell_R}\sigsq_\mu}}}. \\
\eeqn

\subsubsection*{Tree Structure Ratio}

This is also simply the inverse of the tree structure ratio for the grow proposal:

\beqn
\frac{\prob{\treet{*}}}{\prob{\treet{}}}  &=& \frac{\parens{\tothepow{1+d_\eta}{\beta} - \alpha} \padjetastar \nadjetastar}{\alpha\squared{1 - \frac{\alpha}{\tothepow{2 + d_\eta}{\beta}}}}.
\eeqn

\subsection{Change}\label{subapp:change_step}

A change proposal involves picking an internal node and changing its rule by picking both a new available predictor to split on and a new valid split value among values of the selected predictor.  Although this could be implemented for use in any internal node in the tree, for simplicity we limit our implementation to \textit{singly} internal nodes: those that have two terminal daughter nodes and thus, no grand-daughters.

\subsubsection*{Transition Ratio}

The transition to a proposal tree is below:

\beqn
\prob{\treet{} \rightarrow \treet{*}} &=& \prob{\text{CHANGE}} \prob{\text{selecting node $\eta$ to change}} \times \\
&& \prob{\text{selecting the new attribute to split on}} \times \\
&& \prob{\text{selecting the new value to split on}}
\eeqn

When calculating the ratio, the first three terms are shared in both numerator and denominator. The probability of selecting the new value to split on will differ as different split features have different numbers of unique values available. Thus we are left with

\beqn
\frac{\prob{\treet{*} \rightarrow \treet{}}}{\prob{\treet{} \rightarrow \treet{*}}} = \frac{\nadjetastar}{\nadjeta}
\eeqn

\noindent where $\nadjetastar$ is the number of split values available under the proposal tree's splitting rule and $\nadjeta$ is the number of split values available under the original tree's splitting rule.


\subsubsection*{Likelihood Ratio}

The proposal tree differs from the original tree only in the two daughter nodes of the selected change node. These two terminal nodes have the unexplained responses apportioned differently. Denote $R_{1\cdot}$ as the residuals of the first daughter node and $R_{2\cdot}$ as the unexplained responses in the second daughter node. Thus we begin with:

\beqn
\frac{\cprob{\R}{\treet{*}, \sigsq}}{\cprob{\R}{\treet{}, \sigsq}} &=& \frac{\cprob{\Ronestars}{\sigsq}\cprob{\Rtwostars}{\sigsq}}{\cprob{\Rones}{\sigsq}\cprob{\Rtwos}{\sigsq}}
\eeqn

\noindent where the responses denoted with an asterisk are the responses in the proposal tree's daughter nodes.

Substituting Equation~\ref{eq:likelihood_margined} four times and using algebra, the following expression is obtained for the ratio:

\beqn
&& \sqrt{\frac{\parens{\frac{\sigsq}{\sigsqmu} + n_1} \parens{\frac{\sigsq}{\sigsqmu} + n_2}}{\parens{\frac{\sigsq}{\sigsqmu} + n_1^*} \parens{\frac{\sigsq}{\sigsqmu} + n_2^*}}} \times \\
&&  \exp{\oneover{2\sigsq} \parens{\frac{\squared{\sum_{i=1}^{\nonestar} R_{1^*, i}}}{\nonestar + \frac{\sigsq}{\sigsqmu}} + \frac{\squared{\sum_{i=1}^{\ntwostar} R_{2^*, i}}}{\ntwostar + \frac{\sigsq}{\sigsqmu}} - \frac{\squared{\sum_{i=1}^{\none} R_{1, i}}}{\none + \frac{\sigsq}{\sigsqmu}} - \frac{\squared{\sum_{i=1}^{\ntwo} R_{2, i}}}{\ntwo + \frac{\sigsq}{\sigsqmu}}}}
\eeqn

\noindent which simplifies to

\beqn
\exp{\oneover{2\sigsq} \parens{\frac{\squared{\sum_{i=1}^{\nonestar} R_{1^*, i}} - \squared{\sum_{i=1}^{\nonestar} R_{1, i}}}{\none + \frac{\sigsq}{\sigsqmu}} + \frac{\squared{\sum_{i=1}^{\nonestar} R_{2^*, i}} - \squared{\sum_{i=1}^{\nonestar} R_{2, i}}}{\ntwo + \frac{\sigsq}{\sigsqmu}}}}
\eeqn

\noindent if the number of responses in the children do not change in the proposal ($n_1 = n_1^*$ and $n_2 = n_2^*$).

\subsubsection*{Tree Structure Ratio}

The proposal tree has the same structure as the original tree. Thus we only need to take into account the changed node's daughters:

\beqn
\frac{\prob{\treet{*}}}{\prob{\treet{}}} = \frac{\parens{1 - \probsplit{\etaonestar}} \parens{1 - \probsplit{\etatwostar}} \probsplit{\etastar} \probrule{\etastar}}{\parens{1 - \probsplit{\etaone} \parens{1 - \probsplit{\etatwo}}} \probsplit{\eta} \probrule{\eta}}.
\eeqn

The probability of splits remain the same because the daughter nodes are at the same depths. Thus we only need to consider the ratio of the probability of the rules. Once again, the probability of selecting the new value to split on will differ as different split features have different numbers of unique values available. We are left with

\beqn
\frac{\prob{\treet{*}}}{\prob{\treet{}}} = \frac{\nadjeta}{\nadjetastar}.
\eeqn

Note that this is the inverse of the transition ratio. Hence, for the change step, only the likelihood ratio needs to be computed to determine the Metropolis-Hastings ratio $r$.

\section{Bakeoff}\label{app:bakeoff}

We baked off nine regression data sets and assessed out-of-sample RMSE using 10-fold cross-validation. The results are displayed in Table~\ref{tab:bakeoff}.

\begin{table}[htp]
\centering
\begin{tabular}{rccc}
  \hline
Dataset Name & \texttt{bartMachine} & \texttt{BayesTree} & \texttt{randomForest} \\ 
  \hline
boston & 4.66~\, & 4.59~\, & 4.58 \\ 
triazine & 0.04* & 0.05~\, & 0.04 \\ 
ozone & 48.02~\,~\, & 47.75~\,~\, & 48.77~\, \\ 
baseball & 0.02~\, & 0.02* & 0.02 \\ 
wine.red & 0.73~\, & 0.69* & 0.76 \\ 
ankara & 2.62~\, & 2.61~\, & 3.46 \\ 
wine.white & 0.49~\, & 0.49~\, & 0.54 \\ 
pole & 4.00~\, & 3.65~\, & 11.56~\, \\ 
compactiv & 46.17*~\, & 47.92~\,~\, & 40.74~\, \\ 
\hline
\end{tabular}
\caption{Average of 20 replicates of out-of-sample RMSE values on 9 datasets using three machine learning algorithms. Asterisks indicate a significant difference between \texttt{bartMachine} and \texttt{BayesTree} at a significance level of 5\% with a Bonferroni correction. Comparisons with \texttt{randomForest}'s performance were not conducted.}
\label{tab:bakeoff}
\end{table}

We conclude that the implementation outlined in this paper performs approximately the same as the previous implementation with regards to predictive accuracy.

\end{document}
